# бин поиск
- Двоичный поиск заключается в том, что на каждом шаге множество значений делится на две части и дальше обрабатывается та часть множества, где находится нужное значение.



- `Правосторонний поиск` - поиск такого наибольшего (т.е. самого правого) индекса i что a[i]≤x  a[i]≤x, где x - искомый элемент.

- `Левосторонний поиск` - поиск такого наименьшего (т.е. самого левого) индекса i что as[i]≥x  a[i]≥x, где x - искомый элемент.
## Алгоритм двоичного поиска

Идея поиска заключается в том, чтобы брать элемент посередине и сравнивать его с тем который мы ищем. Если искомое больше (в случае правостороннего — не меньше), чем элемент сравнения, то сужаем область поиска так, чтобы новая левая граница была равна индексу середины. В противном случае присваиваем это значение правой границе. Проделываем эту процедуру до тех пор, пока правая граница больше левой более чем на 1.

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = -1                      // l, r — левая и правая границы
    int r = len(a)    
    while l < r - 1                // Запускаем цикл
        m = l + (r - l) / 2           // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример левостороннего бинпоиска*

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = 0                     // l, r — левая и правая границы
    int r = len(a)    
    while l < r                // Запускаем цикл
        m = l + (r - l) / 2            // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример правостороннего бинпоиска*
### Асимптотики
 - худшая *O*(log *n*)
 - лучшее *O*(1)
 - среднее *O*(log *n*)
 p.s по факту это асимптотика чисто бин поиска но к ней еще + асимптотика сортировки которую вы используете

## Нюансы
- часто встречается `(r + l) / 2` но нужно учитывать, что `r + l` может не уместиться в свой тип и тогда все пойдёт покатиться, поэтому лучше использовать `l + (r - l) / 2`