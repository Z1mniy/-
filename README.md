
# Указатели
---
## Стек
---
- **Стек** — это структура данных, которая работает по принципу **LIFO (Last In, First Out)**. Последний добавленный элемент будет удалён первым.

#### Примеры операций на стеке:
1. push(head, x) — добавляет элемент x на вершину стека.
2. pop(head) — удаляет элемент с вершины стека.
3. is_empty() — проверяет, пуст ли стек.
#### Оценка сложности функций стека:

| Удаление: | Добавление: | Поиск: |
| --------- | ----------- | ------ |
| О(1)      | О(1)        | O(n)   |

---
## Очередь
---
- **Очередь** — это структура данных, работающая по принципу FIFO (First In, First Out). Первый добавленный элемент будет удалён первым.

#### Основные операции:
1. enqueue(head, x) — добавляет элемент x в конец очереди.
2. dequeue(head) — удаляет элемент из начала очереди.
3. is_empty() — проверяет, пуста ли очередь.
#### Оценка сложности функций очереди:

| Удаление: | Добавление: | Поиск: |
| --------- | ----------- | ------ |
| О(1)      | О(1)        | O(n)   |

---
## Односвязный список
---
- **Односвязный список** — это структура данных, состоящая из узлов, каждый из которых хранит данные и ссылку на следующий элемент. В односвязном списке элементы связаны только в одном направлении — от первого узла к последнему.

#### Основные компоненты:
1. **Head** — указатель на первый элемент списка.
2. **Node** — структура, которая хранит данные и ссылку на следующий узел.
  
#### Основные операции:
1. Добавление в начало/конец.
2. Удаление.
##### Структура Node:
```cpp
struct Node{
    int key; //значение
    Node* next; //ссылка на следующий элемент
};
```

##### Добавление нового узла в начало списка:
```cpp
void push(Node*& head, int x){
    Node* newNode = new Node(); //создаём новый узел
    newNode->key = x; //значение узла
    newNode->next = head; //ссылка на предыдущий первый элемент
    head = newNode; //теперь это новый head
}
```

##### Добавление нового узла в конец списка:

```cpp
void push_in_end(Node*& head, int key){
    Node* newNode = new Node;    //создаём новый узел
    newNode->key = key;          //значение узла
    newNode->next = nullptr;     //новый узел будет последним, поэтому его next = nullptr

    if(head == nullptr){       //если список пуст
        head = newNode;          //новый узел становится head’ом списка
    } else{
        Node* current = head;
        while(current->next != nullptr){  //ищем последний узел
            current = current->next;
        }
        current->next = newNode;  //добавляем новый узел в конец
    }
}
```

##### Удаление head’а:
```cpp
void pop_head(Node*& head){
    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент
    delete temp;                //удаляем старый head списка
}
```

##### Удаление последнего:
```cpp
void pop_last(){
    //идём до предпоследнего элемента
    Node* current = head;
    while(current->next != nullptr && current->next->next != nullptr){
        current = current->next;
    }

    //у current теперь указатель на предпоследний элемент
    Node* lastNode = current->next;  //последний элемент
    current->next = nullptr;         //убираем связь с последним элементом

    delete lastNode;
}
```

---
## Двусвязный список
---
- **Двусвязный список** — это список, в котором каждый узел содержит ссылки на следующий и предыдущий элементы. Это улучшает доступ к элементам в обе стороны, по сравнению с односвязным списком.
#### Основные компоненты:
1. **Head и Tail** — указатели на первый и последний элементы списка.
2. **Node** — структура, содержащая данные, ссылку на следующий и ссылку на предыдущий узел.

#### Основные операции:
1. Добавление в начало/конец.
2. Удаление.
#### Структура Node:

```cpp
struct Node{
    int key;      //значение узла
    Node* prev;    //указатель на предыдущий элемент
    Node* next;    //указатель на следующий элемент
};
```

#### Добавление узла в конец:
```cpp
void add(int key){
    Node* newNode = new Node(key);  //новый узел

    tail->next = newNode;    //привязываем новый узел к текущему последнему
    newNode->prev = tail;    //устанавливаем предыдущий указатель у нового узла

    tail = newNode;          //обновляем tail
}
```

#### Добавление в начало:
```cpp
void add(int key){
    Node* newNode = new Node(key);  //создаем новый узел

    newNode->next = head;    //привязываем новый узел к текущему первому
    head->prev = newNode;    //устанавливаем предыдущий указатель у текущего первого узла
    head = newNode;          //обновляем head
}

```
  
  
#### Удаление с конца:
```cpp
void delete_tail(){
    Node* temp = tail;

    tail = tail->prev;  //обновляем tail
    tail->next = nullptr;  //разрываем связь с удаляемым узлом

    delete temp;  //удаляем старый tail
}
```

#### Удаление с начала:
```cpp
void delete_head(){
    Node* temp = head;
    
    head = head->next;  //обновляем head
    head->prev = nullptr;  //разрываем связь с удаляемым узлом

    delete temp;  //удаляем старый head
}
```

#### Удаление произвольного:
```cpp
void delete(Node* node){

    if (node->prev){
        node->prev->next = node->next;  //перенаправляем указатель на следующий узел
    }

    if (node->next){
        node->next->prev = node->prev;  //перенаправляем указатель на предыдущий узел
    }

    delete node;  //удаляем сам узел
}
```
  
  
Всё это можно объединить в один красивый псевдокод:

```cpp
void delete(Node* node){

    if (node->prev){
        node->prev->next = node->next;  //перенаправляем указатель на следующий узел
    }

    if (node->next){
        node->next->prev = node->prev;  //перенаправляем указатель на предыдущий узел
    }

    if (node == head){
        head = node->next;  //если удаляется первый элемент, обновляем head
    }

    if (node == tail){
        tail = node->prev;  // Если удаляется последний элемент, обновляем tail
    }

    delete node;  //удаляем сам узел
}
```

---
## Циклический список
---
- **Циклический список** — это разновидность связного списка (одно- или двусвязного), в котором последний узел указывает на первый элемент списка, образуя замкнутый круг.

#### Основные операции:
1. Все основные операции как в обычных связных списках (добавление, удаление, поиск).
2. Особенностью является наличие цикла, который позволяет обойти все элементы, вернувшись к началу.

  
  

Минутка реализации операций на одно- и двусвязном циклических списках!!  

### Односвязный:  
#### Добавление в конец:
```cpp
void add(int key){
    Node* newNode = new Node(key)
    Node* temp = head;

        while(temp->next != head){
            temp = temp->next;
        }

        temp->next = newNode;  //привязываем новый узел
        newNode->next = head;  //новый узел ссылается на head
}
```

#### Добавление в начало:
```cpp
void prepend(int key){
    Node* newNode = new Node(key);
    Node* temp = head;

    while(temp->next != head){  
        temp = temp->next;
    }

    temp->next = newNode;  //последний узел теперь ссылается на новый
    newNode->next = head;  //новый узел ссылается на head
    head = newNode;        //новый узел становится head'ом

}
```

Соединим в одном кодике удаление head’а и произвольного узла:

```cpp
void delete(int key){

    Node* temp = head;
    Node* prev = nullptr;
    
    //если элемент для удаления - это head
    if(head->key == key){
        Node* tail = head;
        while(tail->next != head){  //ищем последний элемент
            tail = tail->next;
        }

        head = head->next;   //head списка меняется
        tail->next = head;   //последний элемент ссылается на новый head

        delete temp;         //удаляем старый head
        return;

    }
    
    //ищем элемент в списке
    while(temp->next != head && temp->key != key){
        prev = temp;
        temp = temp->next;
    }
    if(temp->key == key){
        prev->next = temp->next; //пропускаем текущий узел
        delete temp;             //удаляем узел
    }
}
```

  
  

### Двусвязный:

#### Добавление в конец:
```cpp
void add(int key){
        Node* newNode = new Node(key);
        Node* tail = head->prev; //предыдущий элемент от head'a - это tail

        tail->next = newNode;     //tail ссылается на новый узел
        newNode->prev = tail;     //новый узел ссылается на tail
        newNode->next = head;     //новый узел ссылается на head
        head->prev = newNode;     //head ссылается на новый узел
    }
```
  
  
#### Добавление в начало:
```cpp
void add(int key){

    Node* newNode = new Node(key);
    Node* tail = head->prev; //предыдущий элемент от head - это tail

    newNode->next = head;     //новый элемент ссылается на head
    newNode->prev = tail;     //новый элемент ссылается на tail
    tail->next = newNode;     //tail ссылается на новый элемент
    head->prev = newNode;     //head ссылается на новый элемент
    head = newNode;           //новый элемент становится head'ом

}
```

  
  

Так же как и с односвязным сделаем один код для удаления:

```cpp
void delete(int key){

    Node* temp = head;
    
    //если элемент для удаления - это head
    if(head->key == key){
            Node* tail = head->prev;  //последний элемент - это элемент перед head’ом
            head = head->next;         //head списка меняется
            head->prev = tail;         //новый элемент ссылается на старый tail
            tail->next = head;         //старый tail ссылается на новый head

            delete temp;               //удаляем старый head
            return;

    }

  

    //ищем элемент в списке

    Node* prev = nullptr;
    temp = head;

    //проходим по списку, пока не найдем нужный элемент или не вернемся к head'у
    while(temp->next != head){
        if(temp->key == key){
            prev = temp->prev;
            prev->next = temp->next;    //пропускаем текущий узел
            temp->next->prev = prev;    //пропускаем текущий узел
            
            delete temp;                //удаляем узел
            return;

        }
        temp = temp->next;
    }

    //проверка последнего элемента (он указывает обратно на head)
    if(temp->key == key){

        prev = temp->prev;
        prev->next = temp->next;
        temp->next->prev = prev;

        delete temp;  //удаляем узел
    }
} 
```
  
---
## Стек на списках
---
#### Основные операции:
1. push(head, x) добавляет элемент в начало списка.
2. pop(head) удаляет первый элемент списка.

  
#### push(x):
```cpp
void push(Node*& head, int x){
    Node* newNode = new Node(); //создаём новый узел

	newNode->key = x; //значение узла
    newNode->next = head; //ссылка на предыдущий первый элемент
    head = newNode; //теперь это новый head

}
```

#### pop():

```cpp
void pop(Node*& head){

    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент

    delete temp;                //удаляем старый head списка

}
```

---
## Очередь на списках
---
#### Основные операции:
1. enqueue(head, x) добавляет элемент в конец списка.
2. dequeue(head) удаляет элемент из начала списка.

  

#### enqueue(head, x):
```cpp
void enqueue(Node*& head, int key){

    Node* newNode = new Node;    //создаём новый узел
    
    newNode->key = key;          //значение узла
    newNode->next = nullptr;     //новый узел будет последним, поэтому его next = nullptr

  

    if(head == nullptr){       //если список пуст
        head = newNode;          //новый узел становится head’ом списка
    } else{
        Node* current = head;
        while(current->next != nullptr){  //ищем последний узел
            current = current->next;
        }
        current->next = newNode;  //добавляем новый узел в конец
    }
}
```

#### dequeue(head):
```cpp
void dequeue(Node*& head){

    Node* temp = head;          //временная переменная для хранения текущего head’а
    head = head->next;          //сдвигаем head на следующий элемент

    delete temp;                //удаляем старый head списка

}

```

# бин поиск
- Двоичный поиск заключается в том, что на каждом шаге множество значений делится на две части и дальше обрабатывается та часть множества, где находится нужное значение.



- `Правосторонний поиск` - поиск такого наибольшего (т.е. самого правого) индекса i что `a[i]≤x`  `a[i]≤x`, где x - искомый элемент.

- `Левосторонний поиск` - поиск такого наименьшего (т.е. самого левого) индекса i что `a[i]≥x`  `a[i]≥x`, где x - искомый элемент.
## Алгоритм двоичного поиска

Идея поиска заключается в том, чтобы брать элемент посередине и сравнивать его с тем который мы ищем. Если искомое больше (в случае правостороннего — не меньше), чем элемент сравнения, то сужаем область поиска так, чтобы новая левая граница была равна индексу середины. В противном случае присваиваем это значение правой границе. Проделываем эту процедуру до тех пор, пока правая граница больше левой более чем на 1.

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = -1                      // l, r — левая и правая границы
    int r = len(a)    
    while l < r - 1                // Запускаем цикл
        m = l + (r - l) / 2           // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример левостороннего бинпоиска*

```cpp
int binSearch(int[] a, int key):   // Запускаем бинарный поиск
    int l = 0                     // l, r — левая и правая границы
    int r = len(a)    
    while l < r                // Запускаем цикл
        m = l + (r - l) / 2            // m — середина области поиска
        if a[m] < key
            l = m
        else 
            r = m                  // Сужение границ
    return r
```
*пример правостороннего бинпоиска*
### Асимптотики
 - худшая *O*(log *n*)
 - лучшее *O*(1)
 - среднее *O*(log *n*)
 p.s по факту это асимптотика чисто бин поиска но к ней еще + асимптотика сортировки которую вы используете

## Нюансы
- часто встречается `(r + l) / 2` но нужно учитывать, что `r + l` может не уместиться в свой тип и тогда все пойдёт покатиться, поэтому лучше использовать `l + (r - l) / 2`

# Бинарные деревья поиска
----
- __Дерево__ - иерархическая структура данных, имеющая узлы и ребра, соединяющие эти узлы. 
  (простыми:  __Дерево__ – древовидная структура данных в виде набора связанных узлов.)

- __Узел__ - своего рода node. В нём есть ключ или значение, указатели на дочерние узлы.

- __Лист__ - узел без дочерних узлов. Указатель на дочерние - null.

- __Корень__ - самый верхний узел дерева. Так же - корневой узел.

- __Ребро__ - указатель, связывающий **два** узла.
----


- __Бинарное (*двоичное*) дерево__ — древовидная структура данных, в которой у родителя не может быть более двух детей (т.е их может не быть вовсе).

- **Бинарное (двоичное) дерево поиска** – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):
	- оба поддерева – левое и правое, являются двоичными деревьями поиска;
	
	- у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X;
	
	- у всех узлов правого поддерева произвольного узла X значения ключей данных не меньше, чем значение ключа данных узла X.
---
## Как строить Бинарное дерево поиска
---
### Пример написания узла дерева 
- *Узел дерева может хранить внутри себя значение, а так же указатель только на правый и левый детей.*
 ```cpp
 struct node {  
	 int data;    // данные  
	 node* left;  // левый потомок  
	 node* right; // правый потомок  
};
```
- так же можно хранить указатель на родительский объект (по той же системе как и в двухсвязном списке)
 ```cpp
 struct node {  
	 int data;    // данные  
	 node* left;  // левый потомок  
	 node* right; // правый потомок  
	 node* parent; // указатель на родительский объект
};
```

---
## Операции над бинарным деревом поиска
---
о майн гот ПОИСК (читать с озвучкой пина из смешариков)

### Поиск элементов дерева (O(h))
_Алгоритм:_
1. Для каждого узла, начиная с корня, значение ключа сравнивается с ключом искомым;
2. дальше два исхода: ключи одинаковые - возвращаем node, включи не совпали - рекурсивно вызывается поиск для правого либо левого поддерева (левое - <, правое - >).
3. Если элемент, передается в поиск как null - возвращаем null.
```cpp
node search (node x, int k) {
    if (x == nullptr || k = x.data){
        return x;
    }

    if (k < x.data) {
        return search(x.left, k);
    }
    else {
        return search(x.right, k);
    }
}
```


### Добавление узлов в дерево (O(h))
_Алгоритм:_
1. подается какое-то значение `z`
2. сравнивает `z` с  уже имеющимися значениями в правом и левом поддереве до тех пор пока не натыкается на `NULL`
3. подвешиваем элемент со значением `z` на место где был `NULL`

  ```cpp
  node insert (node x, int z) {
    if (x == nullptr){
        return node(z);
    }

    if (z < x.data) {
        x.left = insert(x.left, z);
    }
    else if (z > x.right) {
        x.right = insert(x.right, z);
    }

    return z;
}
```

- Вторая реализация через родителя 
_Алгоритм:_
1. `x` изначальное дерево, `z` узел/дерево которое мы вставляем
2. спускаемся по дереву до `NULL` сравнивая значения `z` и `x`
3. подвешиваем `z` делая `x` родителем
```cpp
void insert(node x, node z) {
    while (x != nullptr) {
        if (z.data > x.data) {
            if (x.data != nullptr) {
                x = x.right;
            }
            else {
                z.parent = x;
                x.right = z;
                break;
            }
        }
        else if (z.data < x.data) {
            if (x.left != nullptr) {
                x = x.left;
            }
            else {
                z.parent = x;
                x.left = z;
                break;
            }
        }
    }
}
```
### Удаление элемента (O(h))
1. Удаление листа - заменяем указатель на _null_;
2. Удаление узла с одним дочерним узлом - вставляем дочерний узел вместо удаляемого;
3. Удаление узла с двумя дочерними узлами - находим следующий за удаляемым элемент и удаляем его, после чего вставляем найденный элемент вместо удаляемого.


_Нерекурсивный способ:_
```cpp
void delete(node* x, node* z):                 // x — дерево, z — удаляемый элемент
   p = z.parent                                  // предок удаляемого элемента
   if (z.left == null and z.right == null){         // первый случай: удаляемый элемент - лист
     if (p.left == z){
       p.left = null
       }
     if (p.right == z){
       p.right = null
       }
   }else if (z.left == null or z.right == null){     // второй случай: удаляемый элемент имеет одного потомка
       if (z.left == null){                 
           if (p.left == z){
             p.left = z.right
           }else{
             p.right = z.right
             }
           z.right.parent = p 
       }else{
           if (p.left == z){
               p.left = z.left
           }else{
               p.right = z.left
	        }
           z.left.parent = p
        }
   }else{     // третий случай: удаляемый элемент имеет двух потомков
     successor = next(z, x)                   
     z.key = successor.key
     if (successor.parent.left == successor){
       successor.parent.left = successor.right
       if (successor.right != null){
         successor.right.parent = successor.parent
		}
     }else{
       successor.parent.right = successor.right
       if (successor.right != null){
         successor.right.parent = successor.parent
	    }
	 }
   }
```

_Рекурсивно:_
- ! при рекурсивном удалении узла из бинарного дерева нужно рассмотреть три случая: удаляемый элемент находится в левом поддереве текущего поддерева, удаляемый элемент находится в правом поддереве или удаляемый элемент находится в корне. В двух первых случаях нужно рекурсивно удалить элемент из нужного поддерева. Если удаляемый элемент находится в корне текущего поддерева и имеет два дочерних узла, то нужно заменить его минимальным элементом из правого поддерева и рекурсивно удалить этот минимальный элемент из правого поддерева. Иначе, если удаляемый элемент имеет один дочерний узел, нужно заменить его потомком.
```cpp
template<typename T>
node delete(node* root, T z):               // корень поддерева, удаляемый ключ
  if (root == null){
    return root
	}
  if (z < root.key){
    root.left = delete(root.left, z)
  }else if (z > root.key){
    root.right = delete(root.right, z)
  }else if (root.left != null and root.right != null){
    root.key = minimum(root.right).key
    root.right = delete(root.right, root.key)
  }else{
    if (root.left != null){
      root = root.left
    }else if (root.right != null){
      root = root.right
    }else{
      root = null
      }
	}
  return root
```
### Поиск минимального объекта (O(h))
- для поиска минимального числа нужно найти крайний левый объект
```cpp
node min(node x) {
    if (x.left == nullptr) {
        return x;
    }

    return min(x.left);
}
```

### Поиск максимального объекта (O(h))
- для поиска максимального числа нужно найти крайний правый объект
```cpp
node max(node x) {
    if (x.right == nullptr) {
        return x;
    }

    return max(x.right);
}
```
### Поиск следующего элемента. (O(h))

Следующий элемент некоторого элемента, ключ которого минимален и больше ключа элемента искомого.

**Алгоритм действия**: если у `node` есть правое поддерево, то следующий за ним элемент будет минимальным элементом в этом поддереве. Если нет правого поддерева, то нужно следовать вверх, пока не встретим узел, который является левым дочерним узлом своего родителя.

_С информацией о родителе:_
```cpp
node next(node* x){
   if (x.right != null){
      return minimum(x.right)
	}
   y = x.parent
   while (y != null and x == y.right){
      x = y
      y = y.parent
    }
   return y
}
```

_Без информации о родителе:_
```cpp
template<typename T>
node next(T x){
   node* current = root, successor = null    // root — корень дерева
   
   while (current != null){
      if (current.key > x){
         successor = current
         current = current.left
      }else{
         current = current.right
	    }
	}
   return successor
}
```

### Поиск предыдущего элемента. (O(h))

Выполняется аналогично. Если у узла есть левое поддерево, то предыдущий ему элемент будет максимальным элементом в этом поддереве. Если у него нет левого поддерева, то нужно следовать вверх, пока не встретим узел, который является правым дочерним узлом своего родителя.

_С информацией о родителе:_
```cpp
node prev(node* x){
   if (x.left != null){
      return maximum(x.left)
      }
   y = x.parent
   while (y != null and x == y.left){
      x = y
      y = y.parent
    }
   return y
}
```
---
### Обход дерева
---
_префиксная форма_
обход подходит для сортировки
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    cout << tree->data; //Отображаем корень дерева  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
  }  
}
```

_инфиксная форма_
вроде что-то пермяков говорил, но пока не помню
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева 
    cout << tree->data; //Отображаем корень дерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
  }  
}
```

_постфиксная форма_
подходит для удаления дерева тк обхо происходит по форме: левое поддерево, правое поддерево, вершина;
```cpp
void treeprint(node* tree) {  
  if (tree!=NULL) { //Пока не встретится пустой узел  
    treeprint(tree->left); //Рекурсивная функция для левого поддерева  
    treeprint(tree->right); //Рекурсивная функция для правого поддерева  
    cout << tree->data; //Отображаем корень дерева 
  }  
}
```
